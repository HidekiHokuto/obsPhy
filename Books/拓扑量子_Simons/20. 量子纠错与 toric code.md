---
tags: 
created: 2023-07-09 09:15:16
aliases: []
DOI: 
---

现在我们把主题稍微转向量子纠错和环面代码。虽然最初这些想法似乎与我们所讨论的有些不同，但我们将看到它们是极其密切相关的，并使我们得到我们所讨论的许多想法的一个极其重要的应用。

## 20.1. 经典量子信息

### 20.1.1. 内存

#### 经典内存

经典信息的单位是一个经典的二态系统，它可以取 $0$ 或 $1$ 的值。具有 $N$ 位的内存可以处于 $2^N$ 种状态中的任何一种. 每种状态对应于特定的位串，例如 $011100111$.

#### 量子内存

量子信息的单位是量子比特或 qubit. 一个量子双态系统，即由向量张成的二维复[[希尔伯特空间|希尔伯特空间]]，我们通常称之为 $\ket{0}$ 和 $\ket{1}$. 一个量子比特可以处于线性叠加态
$$\ket{\psi} = \alpha\ket{0} +\beta \ket{1}$$
$$\ket{\psi}=\alpha\ket{00} + \beta \ket{01} + \gamma\ket{10} + \delta \ket{11}$$
### 20.1.2. 误差

错误是指某个进程意外地将内存的状态改变到预期的状态之外。我们经常把一次只影响一个比特或一个量子位的情况作为一个错误模型(一个“最小”错误)，尽管更复杂的错误可能会发生。

#### 经典误差校正

有一种简单的方法可以纠正经典记忆中的小错误。不是存储单个位 $0$ 或 $1$，而是存储该位的多个副本(比如，三个副本)。这里我们使用三个“物理”位来存储一个“逻辑”位信息。

我们的内存状态应该是000或111我们把这两种可能性称为代码空间。如果我们检测到系统处于这三个位的任何其他状态(即，不在代码空间中)，我们就知道发生了错误。如果一个物理位发生了错误(例如，如果一个位被意外地翻转了)，我们可以很容易地找到它，因为它会留下我们的内存，并不是所有的物理位都是一样的。例如，如果我们的系统以000开始，第二个比特上引入的错误将使它变成010形式。但是，只要使用多数原则修正系统，就很容易弄清楚发生了什么，并把错误的部分倒回去。所以我们的纠错协议是，连续地比较这三位，如果他们不匹配，切换回一个，这将使他们回到匹配状态。假设错误非常罕见(并且一次只发生在一位上)，该方案是一种有效的防止错误的方法。为了增加保护，可以使用更多的冗余物理位，例如5个物理位或7个物理位用于一个逻辑位。有人可能认为，同样的方法也适用于量子世界:对你想要保护的量子位进行几份拷贝，然后比较它们，看其中一份是否发生了变化。不幸的是，这有两个大问题。第一个是所谓的非克隆定理——不可能完美克隆一个量子位。第二个原因是，衡量一个国家不可避免地会改变它。
